= Solution Patterns: Template Name
:page-layout: home
:sectnums:
:sectlinks:
:doctype: book

Asynchronous communication through message queues is a central part of scalable and decoupled architectures. However, dynamically creating these queues presents challenges related to security and consistency. Traditional workflows often require administrative steps, such as manual queue configuration and permission management, which can introduce slowdowns even with automation tools. In addition, validating authenticated users directly in the messaging middleware adds complexity and couples parts that should ideally be independent.

This solution pattern demonstrates how the OpenID Connect (OIDC) protocol can be used to solve these challenges by decoupling the messaging middleware from the user source. Through OIDC tokens, it is possible to establish a chain of trust based on a common unit of authentication and authorization, simplifying the workflow and standardizing the security model. With this, queues can be dynamically created and securely assigned to individual users, ensuring access control without manual intervention.

The solution combines modern technologies to deliver a robust and scalable approach. Red Hat AMQ Broker ensures highly reliable message brokering, while Red Hat Build of Keycloak manages user identity and authorization. OpenShift Container Platform complements the solution by facilitating middleware management and maintenance through supported operators, which add flexibility, scalability, and the ability to easily incorporate dynamic components. This combination of technologies creates an integrated solution to the challenges of asynchronous communication in dynamic systems.


*Contributors:* https://www.linkedin.com/in/marcelo-daniel-sales/[Marcelo Daniel Sales (Red Hat),role=external,window=_blank]

++++
 <br>
++++
[NOTE]
====
Solutions Patterns help you understand the art of the possible with Red Hat's portfolio, and not intended to be used as is for production environments. You are welcome use any part of this solution pattern for your own workloads.
====
[#use-cases]
== Use cases

Common use cases that can be address with this architecture are:

* *Multi-Tenant Applications:*
 In environments where multiple clients (tenants) share the same infrastructure, dynamic queues enable data isolation between clients. Each queue is linked to a specific client or application, ensuring secure and exclusive access within that domain.

* *Centralized Security in Heterogeneous Environments:*
	In scenarios with multiple systems or services, OIDC centralizes authentication and authorization in a trusted source accessible to all actors. This eliminates the need for specific configurations in each middleware, ensuring consistency and simplifying management in complex ecosystems.

* *Real-Time Payment Processing Systems and Marketplaces:*
 Financial platforms or e-commerce marketplaces can create dynamic queues for each transaction or user, isolating events and notifications, such as order updates or payment confirmations. This ensures that only authenticated actors can access relevant messages.

* *IoT Platforms (Internet of Things):*
 IoT devices can have dynamically created queues upon authentication, isolating messages by device and ensuring that only the corresponding device accesses its queue.

* *Workflow Management Systems:*
 Workflow platforms can assign dynamic queues to each task or user, ensuring access control and simplified traceability for asynchronous operations.

* *Development and Testing Environments:*
 CI/CD tools can use dynamic queues to isolate logs or notifications generated by running pipelines, improving data management during testing.

* *Enhanced Auditability:*
 Dynamic queues that ensure access is restricted to specific consumers provide greater control over message consumption. By linking each queue to a single authenticated user, the system guarantees that messages are consumed exclusively by the intended consumer. This approach strengthens traceability and accountability, enabling precise auditing of message access and consumption patterns.

include::01-pattern.adoc[]
